<!DOCTYPE html>
<html>
<head>
    <title>3D Open Field Shooter</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #score { position: absolute; top: 10px; left: 10px; color: white; font-size: 24px; font-family: Arial; }
        #bullets { position: absolute; top: 40px; left: 10px; color: white; font-size: 24px; font-family: Arial; }
        #target { position: absolute; top: 70px; left: 10px; color: white; font-size: 24px; font-family: Arial; }
    </style>
</head>
<body>
    <div id="score">Score: 0</div>
    <div id="bullets">Bullets: 120</div>
    <div id="target">Target: 40 Kills</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Ground
        const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
        const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x228B22 }); // Forest green
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2; // Lay flat
        scene.add(ground);

        // Skybox (simple blue gradient)
        scene.background = new THREE.Color(0x87CEEB); // Sky blue

        // Add 3D structures: Trees
        const treeTrunkGeometry = new THREE.CylinderGeometry(0.5, 0.5, 5, 8);
        const treeTrunkMaterial = new THREE.MeshBasicMaterial({ color: 0x8B4513 }); // Brown
        const treeFoliageGeometry = new THREE.ConeGeometry(2, 6, 8);
        const treeFoliageMaterial = new THREE.MeshBasicMaterial({ color: 0x006400 }); // Dark green

        function addTree(x, z) {
            const trunk = new THREE.Mesh(treeTrunkGeometry, treeTrunkMaterial);
            trunk.position.set(x, 2.5, z); // Base at ground level, height 5
            scene.add(trunk);

            const foliage = new THREE.Mesh(treeFoliageGeometry, treeFoliageMaterial);
            foliage.position.set(x, 5.5, z); // Top of trunk
            scene.add(foliage);
        }

        // Place trees far away
        addTree(50, 50);
        addTree(-60, 40);
        addTree(30, -70);
        addTree(-40, -60);

        // Add 3D structures: Hills
        const hillGeometry = new THREE.BoxGeometry(100, 10, 20);
        const hillMaterial = new THREE.MeshBasicMaterial({ color: 0x2F4F4F }); // Dark slate gray
        function addHill(x, z) {
            const hill = new THREE.Mesh(hillGeometry, hillMaterial);
            hill.position.set(x, 5, z); // Half height above ground
            scene.add(hill);
        }

        // Place hills in the distance
        addHill(150, 150);
        addHill(-160, 120);
        addHill(0, -200);

        // Player and camera
        camera.position.y = 1; // Eye height
        camera.position.z = 0;

        // Gun (simple rectangular barrel)
        const gunGeometry = new THREE.BoxGeometry(0.2, 0.2, 1);
        const gunMaterial = new THREE.MeshBasicMaterial({ color: 0x808080 }); // Gray
        const gun = new THREE.Mesh(gunGeometry, gunMaterial);
        gun.position.set(0, -0.5, -1); // Position in front of camera
        camera.add(gun); // Attach to camera
        scene.add(camera);

        // Movement controls
        const moveSpeed = 0.1;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        document.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'w': moveForward = true; break;
                case 's': moveBackward = true; break;
                case 'a': moveLeft = true; break;
                case 'd': moveRight = true; break;
            }
        });
        document.addEventListener('keyup', (event) => {
            switch (event.key) {
                case 'w': moveForward = false; break;
                case 's': moveBackward = false; break;
                case 'a': moveLeft = false; break;
                case 'd': moveRight = false; break;
            }
        });

        // Mouse look (only left/right) and shooting
        const mouseSensitivity = 0.002;
        let isShooting = false;
        document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock;
        document.addEventListener('click', () => document.body.requestPointerLock());
        document.addEventListener('mousemove', (event) => {
            if (document.pointerLockElement === document.body || document.mozPointerLockElement === document.body) {
                camera.rotation.y -= event.movementX * mouseSensitivity; // Horizontal only
            }
        });
        document.addEventListener('mousedown', (event) => {
            if (event.button === 0 && (document.pointerLockElement === document.body || document.mozPointerLockElement === document.body)) {
                isShooting = true; // Left mouse button pressed
            }
        });
        document.addEventListener('mouseup', (event) => {
            if (event.button === 0) {
                isShooting = false; // Left mouse button released
            }
        });

        // Bullets
        const bullets = [];
        const bulletSpeed = 0.5;
        const bulletGeometry = new THREE.SphereGeometry(0.05, 8, 8);
        const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff }); // White
        let bulletTimer = 0;
        const bulletSpawnRate = 5; // Frames between bullets when shooting
        let bulletCount = 120; // Starting bullet count
        const bulletDisplay = document.getElementById('bullets');

        // Enemies with improved evil face texture
        const enemies = [];
        const enemySpeed = 0.02;
        const enemyGeometry = new THREE.SphereGeometry(0.5, 16, 16);

        // Create improved evil face texture
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        // Red background
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(0, 0, 64, 64);
        // Black furrowed brow
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.moveTo(16, 12);
        ctx.lineTo(28, 20);
        ctx.lineTo(12, 20);
        ctx.fill(); // Left brow
        ctx.beginPath();
        ctx.moveTo(48, 12);
        ctx.lineTo(52, 20);
        ctx.lineTo(36, 20);
        ctx.fill(); // Right brow
        // Sharp, slanted eyes
        ctx.beginPath();
        ctx.moveTo(16, 24);
        ctx.lineTo(28, 32);
        ctx.lineTo(12, 32);
        ctx.fill(); // Left eye
        ctx.beginPath();
        ctx.moveTo(48, 24);
        ctx.lineTo(52, 32);
        ctx.lineTo(36, 32);
        ctx.fill(); // Right eye
        // Jagged mouth with teeth
        ctx.beginPath();
        ctx.moveTo(20, 40);
        ctx.lineTo(24, 48);
        ctx.lineTo(28, 40);
        ctx.lineTo(32, 48);
        ctx.lineTo(36, 40);
        ctx.lineTo(40, 48);
        ctx.lineTo(44, 40);
        ctx.fill(); // Jagged mouth

        const enemyTexture = new THREE.CanvasTexture(canvas);
        const enemyMaterial = new THREE.MeshBasicMaterial({ map: enemyTexture });

        let spawnTimer = 0;
        const spawnRate = 60; // Frames between spawns

        // Score system
        let score = 0;
        const scoreDisplay = document.getElementById('score');

        // Audio setup for all sounds
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playKillSound() {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.type = 'square'; // Retro sound
            oscillator.frequency.setValueAtTime(500, audioCtx.currentTime); // Start at 500 Hz
            oscillator.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.1); // Drop to 200 Hz
            gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime); // Volume
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2); // Fade out

            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.2); // Sound lasts 0.2 seconds
        }

        function playGunSound() {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.type = 'sawtooth'; // Sharp, punchy sound
            oscillator.frequency.setValueAtTime(300, audioCtx.currentTime); // Start at 300 Hz
            oscillator.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.05); // Quick drop to 100 Hz
            gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime); // Slightly quieter than kill sound
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1); // Fast fade out

            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.1); // Short burst, 0.1 seconds
        }

        function playGameOverSound() {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.type = 'sine'; // Smooth, ominous tone
            oscillator.frequency.setValueAtTime(200, audioCtx.currentTime); // Start at 200 Hz
            oscillator.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.5); // Slow drop to 50 Hz
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime); // Louder for impact
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.8); // Fade out

            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.8); // Lasts 0.8 seconds
        }

        function playWinSound() {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.type = 'triangle'; // Bright, triumphant sound
            oscillator.frequency.setValueAtTime(400, audioCtx.currentTime); // Start at 400 Hz
            oscillator.frequency.setTargetAtTime(600, audioCtx.currentTime + 0.2, 0.1); // Rise to 600 Hz
            oscillator.frequency.setTargetAtTime(800, audioCtx.currentTime + 0.4, 0.1); // Rise to 800 Hz
            gainNode.gain.setValueAtTime(0.25, audioCtx.currentTime); // Moderate volume
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.6); // Fade out

            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.6); // Lasts 0.6 seconds
        }

        // Game loop
        function animate() {
            requestAnimationFrame(animate);

            // Player movement
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0; // Keep movement on XZ plane
            direction.normalize();
            const sideDirection = new THREE.Vector3(-direction.z, 0, direction.x).normalize(); // Perpendicular for strafing

            if (moveForward) camera.position.addScaledVector(direction, moveSpeed);
            if (moveBackward) camera.position.addScaledVector(direction, -moveSpeed);
            if (moveLeft) camera.position.addScaledVector(sideDirection, -moveSpeed);
            if (moveRight) camera.position.addScaledVector(sideDirection, moveSpeed);

            // Spawn bullets on left mouse hold with bullet limit
            if (isShooting && bulletCount > 0) {
                bulletTimer++;
                if (bulletTimer >= bulletSpawnRate) {
                    bulletTimer = 0;
                    const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                    bullet.position.copy(camera.position);
                    bullet.position.y -= 0.5; // Align with gun
                    bullet.velocity = new THREE.Vector3();
                    camera.getWorldDirection(bullet.velocity);
                    bullet.velocity.multiplyScalar(bulletSpeed);
                    scene.add(bullet);
                    bullets.push(bullet);
                    bulletCount--; // Decrease bullet count
                    bulletDisplay.textContent = `Bullets: ${bulletCount}`; // Update display
                    playGunSound(); // Play shooting sound for each bullet
                }
            }

            // Check if bullets are depleted
            if (bulletCount <= 0) {
                document.body.innerHTML += "<h1 style='color:red; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%)'>Game Over: No Bullets Left!</h1>";
                playGameOverSound(); // Play game over sound
                return; // Stop loop
            }

            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.position.add(bullet.velocity);
                if (bullet.position.distanceTo(camera.position) > 50) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                }
            }

            // Spawn enemies
            spawnTimer++;
            if (spawnTimer >= spawnRate) {
                spawnTimer = 0;
                const angle = Math.random() * Math.PI * 2;
                const distance = 20;
                const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
                enemy.position.set(
                    camera.position.x + Math.cos(angle) * distance,
                    0.5, // Half height
                    camera.position.z + Math.sin(angle) * distance
                );
                scene.add(enemy);
                enemies.push(enemy);
            }

            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const direction = new THREE.Vector3()
                    .subVectors(camera.position, enemy.position)
                    .normalize();
                enemy.position.addScaledVector(direction, enemySpeed);

                // Check collision with player (game over)
                if (enemy.position.distanceTo(camera.position) < 1) {
                    document.body.innerHTML += "<h1 style='color:red; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%)'>Game Over: Eaten by Evil Faces!</h1>";
                    playGameOverSound(); // Play game over sound
                    return; // Stop loop
                }

                // Check collision with bullets
                for (let j = bullets.length - 1; j >= 0; j--) {
                    const bullet = bullets[j];
                    if (bullet.position.distanceTo(enemy.position) < 0.55) { // Bullet radius + enemy radius
                        scene.remove(enemy);
                        scene.remove(bullet);
                        enemies.splice(i, 1);
                        bullets.splice(j, 1);
                        score += 1; // Add 1 point per kill
                        scoreDisplay.textContent = `Score: ${score}`; // Update display
                        playKillSound(); // Play sound on kill

                        // Check win condition
                        if (score >= 40) {
                            document.body.innerHTML += "<h1 style='color:green; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%)'>You Win! Evil Faces Cry: 'Why So Good at Headshots?!'</h1>";
                            playWinSound(); // Play winning sound
                            return; // Stop loop
                        }
                        break;
                    }
                }
            }

            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
